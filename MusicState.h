//==============================================================================
// MusicState.h
// Created 2014-08-12
//==============================================================================

#ifndef MUSICSTATE
#define MUSICSTATE

#include <stdint.h>
#include "Random.h"

/*
 * Encapsulates all signals that are generated by the audio analysis tools
 * and used by the light pattern generation tools.
 */

//------------------------------------------------------------------------------
class MusicState {
public:
  volatile uint16_t const* spectrum; // full spectral info
  unsigned sample;  // last hfc sample considered when calculated features
  unsigned hfc;     // HFC content (averaged over some number of windows)
  unsigned samplesSinceOnset; // 0 means this moment is an onset
  unsigned onsetSignificance; // number of standard deviations above the mean at beginning of onset
  unsigned maxSignificance;   // max standard deviations above the mean during onset
  unsigned beat;    // number of the beat in the curent beat train
  unsigned beatpos; // beat subposition in [0, 1024)
  mutable XorShift32 rand;
public:
  // random number based on spectral information
  unsigned random () const;
  // linearly scaled version of hfc signal
  unsigned hfcLin (unsigned scale) const;
  // logarithmically scaled version of hfc signal
  unsigned hfcLog (unsigned scale, unsigned noise_floor = 1150) const;
  // sawtooth wave that rises abruptly at onsets, and decays linearly
  unsigned onsetSaw (unsigned scale, unsigned decay, bool useMaxSignificance = false) const;
};

class SawDecay {
public:
  unsigned lastSample;
  unsigned lastHeight;
  unsigned currentHeight;
  unsigned decayFall;
  unsigned decayTime;
public:
  SawDecay (unsigned df, unsigned dt): lastSample(0), lastHeight(0), currentHeight(0), decayFall(df), decayTime(dt) {}
  void update (unsigned sample, unsigned height);
  inline unsigned height () const {
    return currentHeight;
  }
};

template <unsigned N>
class FlickerFeature {
public:
  unsigned sample;    // last sample at which flicker values were udated
  unsigned timescale; // flicker values update after this many samples
  int scale; // flicker values stay within range -scale and scale
  int step;  // amount that flicker values change each update cycle
  int correlation; // percentage correlation (not in strict statistical sense) with neighboring 4 pixels
  int16_t value[N]; // amount that each pixel's brightness will be ch
public:
  FlickerFeature (): sample(0), timescale(4), scale(512), step(33), correlation(73) { for (unsigned i=0; i<N; ++i) { value[i] = 0; } }
  void init (XorShift32& rand);
  inline void lanternsMode () { timescale = 5; scale = 512; step = 10; correlation = 75; for (unsigned i=0; i<N; ++i) { value[i] = 0; } }
  void update (MusicState const& state);
  int height (unsigned x) const { return value[x]; } 
};

template <unsigned N>
void FlickerFeature<N>::init (XorShift32& rand) {
  /*
  unsigned mod20 = rand.uint32() % 20;
  switch (mod20) {
    case 19:
      timescale = 7;
      break;
    case 18:
      timescale = 6;
      break;
    case 0:
      timescale = 2;
      break;
    default:
      timescale = 2 + rand.uint32() % 3;
  }
  */
  timescale = 3 + rand.uint32() % 7;

  scale = 100 + rand.uint32() % 250;
  step =  scale / 15 - 10 + rand.uint32() % 12;
  if (step < 1) { step = 1; }
  else if (step >= scale) { step = scale / 2; }

  correlation = 25 + rand.uint32() % 75;
}

template <unsigned N>
void FlickerFeature<N>::update (MusicState const& state) {
  if (state.sample >= sample + timescale) {
    sample = state.sample;
    int temp;
    for (unsigned x=0; x<N; ++x) {
      unsigned random_uint = state.rand.uint32();
      int random_int = (random_uint % (2 * scale)) - scale;
      if (random_int > value[x]) {
        temp = value[x] + step;
        value[x] = (temp > 0x7FFF) ? 0x7FFF : temp;
      } else if (random_int < value[x]) {
        temp = value[x] - step;
        value[x] = (temp < -0x8000) ? -0x8000 : temp;
      }
    }
    for (unsigned x=0; x<N; ++x) {
      int sum = 0;
      sum += value[(x + N - 2) % N];
      sum += value[(x + N - 1) % N];
      sum += value[x];
      sum += value[(x + 1) % N];
      sum += value[(x + 2) % N];
      value[x] = (correlation * sum / 5 + (100 - correlation) * value[x]) / 100;
    }
  }
}


//==============================================================================
// Log2
//==============================================================================

//------------------------------------------------------------------------------
uint16_t log2_fp (uint16_t x_16t);

#endif

